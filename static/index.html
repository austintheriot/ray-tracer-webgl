<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ray Tracer WebGL</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="/main.js" defer></script>
    <style>
        canvas {
            width: 100%;
            max-width: 100vw;
            image-rendering: pixelated;
            object-fit: contain;
        }
    </style>
</head>

<body>
    <canvas></canvas>
    <button>Save Image</button>
    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
        in vec4 a_position;

        out vec2 v_position;

        void main() {
            v_position = a_position.xy;
            gl_Position = a_position;
        }
      </script>

    <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
        precision highp float;

        // PSEUDO-RANDOM NUMBER GENERATORS //////////////////////////////////////////////////////
        #define M1 1597334677U     //1719413*929
        #define M2 3812015801U     //140473*2467*11
        #define M3 3299493293U     //467549*7057

        #define F0 (1.0/float(0xffffffffU))

        #define hash(n) n*(n^(n>>15))

        #define coord1(p) (p*M1)
        #define coord2(p) (p.x*M1^p.y*M2)
        #define coord3(p) (p.x*M1^p.y*M2^p.z*M3)

        float hash1(uint n){return float(hash(n))*F0;}
        vec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}
        vec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}
        vec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}


        // START //////////////////////////////////////////////////////
        uniform float u_width;
        uniform float u_height;

        struct Ray {
            vec3 origin;
            vec3 direction;
        };

        struct Sphere {
            vec3 center;
            float radius;
        };

        struct HitRecord {
            vec3 hit_point;
            float hit_t;
            vec3 normal;
            bool front_face;
        };

        out vec4 o_color;

        in vec2 v_position;

        vec3 ray_at(in Ray r, float hit_t) {
            return r.origin + r.direction * hit_t;
        }

        float length_squared(in vec3 v) {
            return pow(length(v), 2.);
        }

        void set_hit_record_front_face(inout HitRecord hit_record, in Ray r, in vec3 outward_normal) {
            hit_record.front_face = dot(r.direction, outward_normal) < 0.;
            if (hit_record.front_face) {
                hit_record.normal = outward_normal;
            } else {
                hit_record.normal = -outward_normal;
            }
        }

        bool hit_sphere(in Sphere sphere, in Ray r, in float t_min, in float t_max, inout HitRecord hit_record) {
            vec3 oc = r.origin - sphere.center;
            float a = length_squared(r.direction);
            float half_b = dot(oc, r.direction);
            float c = length_squared(oc) - pow(sphere.radius, 2.);
            float discriminant = pow(half_b, 2.) - a * c;

            // no hit
            if (discriminant < 0.) return false;

            // there was a hit, but it's not within an acceptable range
            float sqrtd = sqrt(discriminant);
            float root = (-half_b - sqrtd) / a;
            if (root < t_min || t_max < root) {
                root = (-half_b + sqrtd) / a;
                if (root < t_min || t_max < root) {
                    return false;
                }
            }

            // hit is within acceptable range: calculate hit point, normal, and t
            vec3 new_hit_point = ray_at(r, root);
            // only save new hit_point if it is in front of the previous hit point
            if (new_hit_point.z > hit_record.hit_point.z) {
                hit_record.hit_t = root;
                hit_record.hit_point = ray_at(r, hit_record.hit_t);
                vec3 outward_normal = (hit_record.hit_point - sphere.center) / sphere.radius;
                set_hit_record_front_face(hit_record, r, outward_normal);
            }
           return true;
        }

        bool hit_world(in Ray r, in float t_min, in float t_max, inout HitRecord hit_record) {
            Sphere sphere_list[] = Sphere[2](
                Sphere(vec3(0., 0., -1.), 0.5),
                Sphere(vec3(0., -100.5, -1.), 100.)
            );
            
            bool hit = false;
            for (int i = 0; i < sphere_list.length(); i++) {
                Sphere sphere = sphere_list[i];
                hit = hit_sphere(sphere, r, t_min, t_max, hit_record) || hit;
            }

            return hit;
        }

        vec3 ray_color(in Ray r) {
            Sphere sphere_1 = Sphere(vec3(0., 0., -1.), 0.5);
            float max_t = 10000000000.;
            float min_t = 0.001;

            // hit record gets modified with hit details if there was a hit
            HitRecord hit_record = HitRecord(vec3(0., 0., -max_t), 0., vec3(0.), false);
            bool was_hit = hit_world(r, min_t, max_t, hit_record);
            if (was_hit) {
                return (hit_record.normal + 1.) * 0.5;
            }

            vec3 unit_direction = normalize(r.direction);
            float t = 0.5 * (unit_direction.y + 1.0);
            return mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), t);
        }
        
        void main() {
            // these can be initialized as uniforms instead
            int samples_per_pixel = 100;
            float aspect_ratio = u_width / u_height;
            float viewport_height = 2.0;
            float viewport_width = aspect_ratio * viewport_height;
            float focal_length = 1.0;
            vec3 camera_origin = vec3(0.);
            vec3 viewport_horizontal_vec = vec3(viewport_width, 0., 0.);
            vec3 viewport_vertical_vec = vec3(0., viewport_height, 0.);
            vec3 lower_left_corner = camera_origin - viewport_horizontal_vec / 2. - viewport_vertical_vec / 2. - vec3(0., 0., focal_length);

            // get current position on viewport, mapped from -1->1 to 0->1
            // (i.e. percentage of width, percentage of height)
            vec2 uv = (v_position + 1.) * 0.5;

            // accumulate color per pixel
            vec3 color = vec3(0.);
            for (int i = 0; i < samples_per_pixel; i++) {
                uint random_seed = floatBitsToUint(uv.x * uv.y * 1000. * float(i));
                vec2 random = hash2(random_seed);
                vec2 random_within_pixel = random / vec2(u_width, u_height);

                // uv +/- the value of 1 pixel
                vec2 randomized_uv = uv + random_within_pixel;

                // create ray from camera origin to viewport
                vec3 ray_direction = lower_left_corner + randomized_uv.x * viewport_horizontal_vec + randomized_uv.y * viewport_vertical_vec - camera_origin;
                Ray r = Ray(camera_origin, ray_direction);


                color += ray_color(r);
            }

            // scale color by number of samples
            float scale = (1. / float(samples_per_pixel));
            color *= scale;
        
            o_color = vec4(color, 1.);
          }
      </script>
</body>

</html>